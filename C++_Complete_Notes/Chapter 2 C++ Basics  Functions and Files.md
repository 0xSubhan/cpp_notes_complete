### Function
>A **function** is a reusable sequence of statements designed to do a particular job.

>Functions can call functions that call other functions

```cpp
#include <iostream> // for std::cout

void doB()
{
    std::cout << "In doB()\n";
}


void doA()
{
    std::cout << "Starting doA()\n";

    doB();

    std::cout << "Ending doA()\n";
}

// Definition of function main()
int main()
{
    std::cout << "Starting main()\n";

    doA();

    std::cout << "Ending main()\n";

    return 0;
}
```

### Return Value
>Return values provide a way for functions to return a single value back to the function’s caller.
Functions provide a way to minimize redundancy in our programs.

>Status Code: why we return 0 in main function? The return value from `main()` is sometimes called a **status code** (or less commonly, an **exit code**, or rarely a **return code**). The status code is used to signal whether your program was successful or not.
>Your `main` function should return the value `0` if the program ran normally.

>Follow DRY: “Don’t repeat yourself”. If you need to do something more than once, consider how to modify your code to remove as much redundancy as possible. Variables can be used to store the results of calculations that need to be used more than once (so we don’t have to repeat the calculation). Functions can be used to define a sequence of statements we want to execute more than once. And loops (which we’ll cover in a later chapter) can be used to execute a statement more than once.
Like all best practices, DRY is meant to be a guideline, not an absolute. Reader Yariv has [noted](https://www.learncpp.com/cpp-tutorial/function-return-values-value-returning-functions/#comment-593257) that DRY can harm overall comprehension when code is broken into pieces that are too small.

> Void functions are used for its behavior not for value.

### How parameters and arguments work together
>When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments is _copied_ into the matching parameter (using copy initialization). This process is called **pass by value**. Function parameters that utilize pass by value are called **value parameters**.

> We can use return value of any function as an argument for another function.

### Out of scope vs going out of scope

[Out of Scope Vs Going Out of Scope](https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/#:~:text=%E2%80%9COut%20of%20scope,and%20destroyed%20often.)

> Define your local variables as close to their first use as reasonable.

### Temporary Objects
>A **temporary object** (also sometimes called an **anonymous object**) is an unnamed object that is used to hold a value that is only needed for a short period of time. Temporary objects are generated by the compiler when they are needed.

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value of input back to the caller
}

int main()
{
	std::cout << getValueFromUser() << '\n'; // where does the returned value get stored?

	return 0;
}
```
>In the above program, the function `getValueFromUser()` returns the value stored in local variable `input` back to the caller. Because `input` will be destroyed at the end of the function, the caller receives a copy of the value so that it has a value it can use even after `input` is destroyed.
But where is the value that is copied back to the caller stored? We haven’t defined any variables in `main()`. The answer is that the return value is stored in a temporary object. This temporary object is then passed to `std::cout` to be printed.

>Return by value returns a temporary object (that holds a copy of the return value) to the caller.
>[More About Temporary Objects](https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/#:~:text=Temporary%20objects%20have,of%20operator%3C%3C.)

### Quiz for scope question
```cpp
#include <iostream>

void doIt(int x)
{
    int y{ 4 };
    std::cout << "doIt: x = " << x << " y = " << y << '\n';

    x = 3;
    std::cout << "doIt: x = " << x << " y = " << y << '\n';
}

int main()
{
    int x{ 1 };
    int y{ 2 };

    std::cout << "main: x = " << x << " y = " << y << '\n';

    doIt(x);

    std::cout << "main: x = " << x << " y = " << y << '\n';

    return 0;
}
```

### Foward Declaration
> The process of declaring the function before main function and defining it after the main function is what's called forward declaration and it is recommended!

[Forgetting the function body?](https://www.learncpp.com/cpp-tutorial/forward-declarations/#:~:text=Forgetting%20the%20function,was%20never%20defined.)

>The term “declaration” is commonly used to mean “pure declaration”, and the term “definition” used for anything that is both a definition and a declaration. We use this common nomenclature in the example column comments.

[The One Defination Rule](https://www.learncpp.com/cpp-tutorial/forward-declarations/#:~:text=example%20column%20comments.-,The%20one%20definition%20rule%20(ODR),this%20for%20now%20%2D%2D%20we%E2%80%99ll%20bring%20it%20back%20up%20when%20it%E2%80%99s%20relevant.,-Related%20content)

### For multiple files
```cpp
"args": [
    "${fileDirname}/main.cpp",
    "${fileDirname}/add.cpp",
    "-o", "${fileDirname}/${fileBasenameNoExtension}"
]
```
> In task.json file ---

> We have to include standard library in each different file to use std properties and if there is an function in second file then in main file we will use forward declaration to tell the compiler it exits in some other file!!!

### Naming collision or Naming conflict
>C++ requires that all identifiers be non-ambiguous. If two identical identifiers are introduced into the same program in a way that the compiler or linker can’t tell them apart, the compiler or linker will produce an error. This error is generally referred to as a **naming collision** (or **naming conflict**).

```cpp
#include <iostream>
// Main File

void myFcn(int x)
{
    std::cout << 2 * x;
}

int main()
{
    return 0;
}
```

```cpp
#include <iostream>
// Second File

void myFcn(int x)
{
    std::cout << x;
}
```
> In this example, When the compiler compiles this program, it will compile _a.cpp_ and _main.cpp_ independently, and each file will compile with no problems.
> However, when the linker executes, it will link all the definitions in _a.cpp_ and _main.cpp_ together, and discover conflicting definitions for function `myFcn()`. The linker will then abort with an error. Note that this error occurs even though `myFcn()` is never called!

### Scope Region
>-Identifiers declared inside the global scope are in scope from the point of declaration to the end of the file.
-Although variables can be defined in the global namespace, this should generally be avoided

### Why Use std directive?
>A **using directive** allows us to access the names in a namespace without using a namespace prefix. So in the above example, when the compiler goes to determine what identifier `cout` is, it will match with `std::cout`, which, because of the using-directive, is accessible as just `cout`.

```cpp
using namespace std; // no need for using namespace prefix like std::cout
```

### Preprocessor
>Proprocessor is a program.
>It makes changes but not modify the original code but the changes are temporary like striping comments etc.
>When the preprocessor has finished processing a code file, the result is called a **translation unit**. This translation unit is what is then compiled by the compiler.

>The entire process of preprocessing, compiling, and linking is called **translation**.

### Preprocessor directives
>When the preprocessor runs, it scans through the code file (from top to bottom), looking for preprocessor directives. **Preprocessor directives** (often just called _directives_) are instructions that start with a _#_ symbol and end with a newline (NOT a semicolon). These directives tell the preprocessor to perform certain text manipulation tasks. Note that the preprocessor does not understand C++ syntax -- instead, the directives have their own syntax (which in some cases resembles C++ syntax, and in other cases, not so much).

>**Using Directives** are not preprocessor directives (and thus are not processed by the preprocessor). So while the term `directive` _usually_ means a `preprocessor directive`, this is not always the case.

> When we #include a file then preprocessor replaces the #include file with contents of that file lets say iostream.

>***translation unit***: When the preprocessor has finished processing a code file, the result is called a **translation unit**. This translation unit is what is then compiled by the compiler.
>Each translation unit typically consists of a single code (.cpp) file and all header files it #includes (applied recursively, since header files can #include other header files).

### Conditional Compilation
>The _conditional compilation_ preprocessor directives allow you to specify under what conditions something will or won’t compile.

>The _#ifdef_ preprocessor directive allows the preprocessor to check whether an identifier has been previously defined via #define. If so, the code between the _#ifdef_ and matching _#endif_ is compiled. If not, the code is ignored.

```cpp
#include <iostream>

#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout << "Joe\n"; // will be compiled since PRINT_JOE is defined
#endif

#ifdef PRINT_BOB
    std::cout << "Bob\n"; // will be excluded since PRINT_BOB is not defined
#endif

    return 0;
}
```

>In place of `#ifdef PRINT_BOB` and `#ifndef PRINT_BOB`, you’ll also see `#if defined(PRINT_BOB)` and `#if !defined(PRINT_BOB)`. These do the same, but use a slightly more C++-style syntax.

### if 0 conditional compilation
>One more common use of conditional compilation involves using _#if 0_ to exclude a block of code from being compiled (as if it were inside a comment block):

```cpp
#include <iostream>

int main()
{
    std::cout << "Joe\n";

#if 0 // Don't compile anything starting here
    std::cout << "Bob\n";
    std::cout << "Steve\n";
#endif // until this point

    return 0;
}
```
> If we change 0 to 1 in if then the code of block will compile

### Macro substitution within other preprocessor commands
```cpp
#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout << "Joe\n"; // will be compiled since PRINT_JOE is defined
#endif

    return 0;
}
```

>Since we defined _PRINT_JOE_ to be nothing, how come the preprocessor didn’t replace _PRINT_JOE_ in _#ifdef PRINT_JOE_ with nothing and exclude the output statement from compilation?
In most cases, macro substitution does not occur when a macro identifier is used within another preprocessor command.

```cpp
#define FOO 9 // Here's a macro substitution

#ifdef FOO // This FOO does not get replaced with 9 because it’s part of another preprocessor directive
    std::cout << FOO << '\n'; // This FOO gets replaced with 9 because it's part of the normal code
#endif
```

### Header File
> When we use multiple files in our program then we have to do forward declaration for each file and it arises the issue of scalability of files for example what if we have 100+ files so we have to do forward declaration 100 times which is not good so we use the concept of header file, header file contains all the declaration and we just have to include it into our file and we are good.

>Header files allow us to put declarations in one place and then import them wherever we need them. This can save a lot of typing in multi-file programs.

For Example:
```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```
>_std::cout_ has been forward declared in the “iostream” header file. When we `#include <iostream>`, we’re requesting that the preprocessor copy all of the content (including forward declarations for std::cout) from the file named “iostream” into the file doing the #include.

>Header files are not added to compile command, they are implicitly included by #include statements and compiled as part of your source files.

>If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).

```cpp
// Second.h

// We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!
```

```cpp
// main.cpp

#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

```cpp
// second.cpp

#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.

int add(int x, int y)
{
    return x + y;
}
```

>When the preprocessor processes the `#include "add.h"` line, it copies the contents of add.h into the current file at that point. Because our _add.h_ contains a forward declaration for function _add()_, that forward declaration will be copied into _main.cpp_. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top of _main.cpp_.

![[Pasted image 20250506200737.png]]

### How including definitions in a header file results in a violation of the one-definition rule
> For now, you should avoid putting function or variable definitions in header files. Doing so will generally result in a violation of the one-definition rule (ODR) in cases where the header file is included into more than one source file.

[Example](https://www.learncpp.com/cpp-tutorial/header-files/#:~:text=How%20including%20definitions,each%20of%20these.)

### For VS Code users

In your _tasks.json_ configuration file, add a new line in the _“Args”_ section:  
`"-I./source/includes",`

There is no space after the `-I`. For a full path (rather than a relative path), remove the `.` after `-I`.

### Source files should include their paired header [](https://www.learncpp.com/cpp-tutorial/header-files/#corresponding_include)
>In C++, it is a best practice for code files to #include their paired header file (if one exists). This allows the compiler to catch certain kinds of errors at compile time instead of link time. For example:

[Example](https://www.learncpp.com/cpp-tutorial/header-files/#:~:text=time.%20For%20example%3A-,add.h%3A,Source%20files%20should%20%23include%20their%20paired%20header%20file%20(if%20one%20exists).,-Do%20not%20%23include)

### Do not #include .cpp files
Although the preprocessor will happily do so, you should generally not `#include` .cpp files. These should be added to your project and compiled.

There are number of reasons for this:

- Doing so can cause naming collisions between source files.
- In a large project it can be hard to avoid one definition rules (ODR) issues.
- Any change to such a .cpp file will cause both the .cpp file and any other .cpp file that includes it to recompile, which can take a long time. Headers tend to change less often than source files.
- It is non-conventional to do so.

Best practice

>Avoid #including .cpp files.

### Angled brackets vs double quotes [](https://www.learncpp.com/cpp-tutorial/header-files/#includemethod)

>Use double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system. (Its A Rule).

### Why doesn’t iostream have a .h extension?

[About This!](https://www.learncpp.com/cpp-tutorial/header-files/#:~:text=Another%20commonly%20asked,a%20.h%20extension.)

>Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.

### Including header files from other directories
[Click Here](https://www.learncpp.com/cpp-tutorial/header-files/#:~:text=Including%20header%20files,every%20code%20file.)

>Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.

### The order of inclusion for header files

- Suppose `headerA.h` needs something from `headerB.h` but forgets to include it. Now, the correctness of the code depends on the order of inclusion in the source file:
    
    - If you include `headerB.h` before `headerA.h`, the code might compile because `headerB.h`'s declarations are visible to `headerA.h` when it's processed.
        
    - If you include `headerA.h` first, the compiler will error out because `headerA.h` uses undeclared types/functions from `headerB.h`.
        
- The second case (error) is actually better because it reveals the missing include in `headerA.h`, forcing you to fix it.

To catch such missing includes early, follow this order in your source files (e.g., `.cpp` files):

1. **The paired header file**:
    
    - If you're in `add.cpp`, include `add.h` first. This ensures `add.h` is self-sufficient (if it isn't, you'll get an error immediately).
        
    - Example: `#include "add.h"`.
        
2. **Other headers from the same project**:
    
    - Include other local project headers next. Example: `#include "mymath.h"`.
        
3. **3rd-party library headers**:
    
    - Include headers from external libraries (e.g., Boost, Qt). Example: `#include <boost/tuple/tuple.hpp>`.
        
4. **Standard library headers**:
    
    - Include standard library headers last. Example: `#include <iostream>`.
        

>Why This Order?

- If `add.h` forgets to include a standard library header (e.g., `<string>`), including `add.h` first will likely cause a compile error when the missing dependency is used. This reveals the problem early.
    
- If you included standard library headers first, `add.h` might accidentally "work" because the needed declarations were pulled in indirectly, hiding the issue.

### The duplicate definition problem
>we noted that a variable or function identifier can only have one definition (the one definition rule). Thus, a program that defines a variable identifier more than once will cause a compile error.

Consider the following academic example:

square.h:
```cpp
int getSquareSides()
{
    return 4;
}
```
wave.h
```cpp
#include "square.h"
```
main.cpp
```cpp
#include "square.h"
#include "wave.h"

int main()
{
    return 0;
}
```
>This seemingly innocent looking program won’t compile! Here’s what’s happening. First, _main.cpp_ #includes _square.h_, which copies the definition for function _getSquareSides_ into _main.cpp_. Then _main.cpp_ #includes _wave.h_, which #includes _square.h_ itself. This copies contents of _square.h_ (including the definition for function _getSquareSides_) into _wave.h_, which then gets copied into _main.cpp_.

How to solve this problem?

### Header Guards
>we can avoid the above problem via a mechanism called a **header guard** (also called an **include guard**). Header guards are conditional compilation directives that take the following form:

```cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations (and certain types of definitions) here

#endif
```
>When this header is #included, the preprocessor will check whether _SOME_UNIQUE_NAME_HERE_ has been previously defined in this translation unit. If this is the first time we’re including the header, _SOME_UNIQUE_NAME_HERE_ will not have been defined. Consequently, it #defines _SOME_UNIQUE_NAME_HERE_ and includes the contents of the file. If the header is included again into the same file, _SOME_UNIQUE_NAME_HERE_ will already have been defined from the first time the contents of the header were included, and the contents of the header will be ignored (thanks to the #ifndef).

```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

#endif
```
### 📌 Important Notes

- `SQUARE_H` can be **any name** — but by **convention**, we use:
    
    - The **filename**, in **all caps**, with `_` instead of `.`.
        
    - Example:
        
        - For `square.h` → use `SQUARE_H`
            
        - For `math_utils.h` → use `MATH_UTILS_H`

### Header Guard For Large Project
[Read](https://www.learncpp.com/cpp-tutorial/header-guards/#:~:text=For%20advanced%20readers,or%20FILE_CREATION%2DDATE_H.)

### Updating Our Previous Code with Header Guard

square.h
```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

#endif
```
wave.h
```cpp
#ifndef WAVE_H
#define WAVE_H

#include "square.h"

#endif
```
main.cpp
```cpp
#include "square.h"
#include "wave.h"

int main()
{
    return 0;
}
```

After the preprocessor resolves all of the #include directives, this program looks like this:

```cpp
// Square.h included from main.cpp
#ifndef SQUARE_H // square.h included from main.cpp
#define SQUARE_H // SQUARE_H gets defined here

// and all this content gets included
int getSquareSides()
{
    return 4;
}

#endif // SQUARE_H

#ifndef WAVE_H // wave.h included from main.cpp
#define WAVE_H
#ifndef SQUARE_H // square.h included from wave.h, SQUARE_H is already defined from above
#define SQUARE_H // so none of this content gets included

int getSquareSides()
{
    return 4;
}

#endif // SQUARE_H
#endif // WAVE_H

int main()
{
    return 0;
}
```

### Header guards do not prevent a header from being included once into different code files

[Read](https://www.learncpp.com/cpp-tutorial/header-guards/#:~:text=Note%20that%20the%20goal%20of,to%20the%20definition%20of%20getSquareSides)

### Alternative: pragma once
>`#pragma once` serves the same purpose as header guards: to avoid a header file from being included multiple times. With traditional header guards, the developer is responsible for guarding the header (by using preprocessor directives `#ifndef`, `#define`, and `#endif`). With `#pragma once`, we’re requesting that the compiler guard the header. How exactly it does this is an implementation-specific detail.

```cpp
#pragma once

// your code here
```

### How to Design your programs

[Read](https://www.learncpp.com/cpp-tutorial/how-to-design-your-first-programs/#:~:text=Design%20step%201,FAIL%20P.%2071)

>Remember: Don’t implement your entire program in one go. Work on it in steps, testing each step along the way before proceeding.

### Chapter 2: Summary

[Summary](https://www.learncpp.com/cpp-tutorial/chapter-2-summary-and-quiz/)





