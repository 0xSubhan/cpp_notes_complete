### Function
>AÂ **function**Â is a reusable sequence of statements designed to do a particular job.

>Functions can call functions that call other functions

```cpp
#include <iostream> // for std::cout

void doB()
{
    std::cout << "In doB()\n";
}


void doA()
{
    std::cout << "Starting doA()\n";

    doB();

    std::cout << "Ending doA()\n";
}

// Definition of function main()
int main()
{
    std::cout << "Starting main()\n";

    doA();

    std::cout << "Ending main()\n";

    return 0;
}
```

### Return Value
>Return values provide a way for functions to return a single value back to the functionâ€™s caller.
Functions provide a way to minimize redundancy in our programs.

>Status Code: why we return 0 in main function? The return value fromÂ `main()`Â is sometimes called aÂ **status code**Â (or less commonly, anÂ **exit code**, or rarely aÂ **return code**). The status code is used to signal whether your program was successful or not.
>YourÂ `main`Â function should return the valueÂ `0`Â if the program ran normally.

>Follow DRY: â€œDonâ€™t repeat yourselfâ€. If you need to do something more than once, consider how to modify your code to remove as much redundancy as possible. Variables can be used to store the results of calculations that need to be used more than once (so we donâ€™t have to repeat the calculation). Functions can be used to define a sequence of statements we want to execute more than once. And loops (which weâ€™ll cover in a later chapter) can be used to execute a statement more than once.
Like all best practices, DRY is meant to be a guideline, not an absolute. Reader Yariv hasÂ [noted](https://www.learncpp.com/cpp-tutorial/function-return-values-value-returning-functions/#comment-593257)Â that DRY can harm overall comprehension when code is broken into pieces that are too small.

> Void functions are used for its behavior not for value.

### How parameters and arguments work together
>When a function is called, all of the parameters of the function are created as variables, and the value of each of the arguments isÂ _copied_Â into the matching parameter (using copy initialization). This process is calledÂ **pass by value**. Function parameters that utilize pass by value are calledÂ **value parameters**.

> We can use return value of any function as an argument for another function.

### Out of scope vs going out of scope

[Out of Scope Vs Going Out of Scope](https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/#:~:text=%E2%80%9COut%20of%20scope,and%20destroyed%20often.)

> Define your local variables as close to their first use as reasonable.

### Temporary Objects
>AÂ **temporary object**Â (also sometimes called anÂ **anonymous object**) is an unnamed object that is used to hold a value that is only needed for a short period of time. Temporary objects are generated by the compiler when they are needed.

```cpp
#include <iostream>

int getValueFromUser()
{
 	std::cout << "Enter an integer: ";
	int input{};
	std::cin >> input;

	return input; // return the value of input back to the caller
}

int main()
{
	std::cout << getValueFromUser() << '\n'; // where does the returned value get stored?

	return 0;
}
```
>In the above program, the functionÂ `getValueFromUser()`Â returns the value stored in local variableÂ `input`Â back to the caller. BecauseÂ `input`Â will be destroyed at the end of the function, the caller receives a copy of the value so that it has a value it can use even afterÂ `input`Â is destroyed.
But where is the value that is copied back to the caller stored? We havenâ€™t defined any variables inÂ `main()`. The answer is that the return value is stored in a temporary object. This temporary object is then passed toÂ `std::cout`Â to be printed.

>Return by value returns a temporary object (that holds a copy of the return value) to the caller.
>[More About Temporary Objects](https://www.learncpp.com/cpp-tutorial/introduction-to-local-scope/#:~:text=Temporary%20objects%20have,of%20operator%3C%3C.)

### Quiz for scope question
```cpp
#include <iostream>

void doIt(int x)
{
    int y{ 4 };
    std::cout << "doIt: x = " << x << " y = " << y << '\n';

    x = 3;
    std::cout << "doIt: x = " << x << " y = " << y << '\n';
}

int main()
{
    int x{ 1 };
    int y{ 2 };

    std::cout << "main: x = " << x << " y = " << y << '\n';

    doIt(x);

    std::cout << "main: x = " << x << " y = " << y << '\n';

    return 0;
}
```

### Foward Declaration
> The process of declaring the function before main function and defining it after the main function is what's called forward declaration and it is recommended!

[Forgetting the function body?](https://www.learncpp.com/cpp-tutorial/forward-declarations/#:~:text=Forgetting%20the%20function,was%20never%20defined.)

>The term â€œdeclarationâ€ is commonly used to mean â€œpure declarationâ€, and the term â€œdefinitionâ€ used for anything that is both a definition and a declaration. We use this common nomenclature in the example column comments.

[The One Defination Rule](https://www.learncpp.com/cpp-tutorial/forward-declarations/#:~:text=example%20column%20comments.-,The%20one%20definition%20rule%20(ODR),this%20for%20now%20%2D%2D%20we%E2%80%99ll%20bring%20it%20back%20up%20when%20it%E2%80%99s%20relevant.,-Related%20content)

### For multiple files
```cpp
"args": [
    "${fileDirname}/main.cpp",
    "${fileDirname}/add.cpp",
    "-o", "${fileDirname}/${fileBasenameNoExtension}"
]
```
> In task.json file ---

> We have to include standard library in each different file to use std properties and if there is an function in second file then in main file we will use forward declaration to tell the compiler it exits in some other file!!!

### Naming collision or Naming conflict
>C++ requires that all identifiers be non-ambiguous. If two identical identifiers are introduced into the same program in a way that the compiler or linker canâ€™t tell them apart, the compiler or linker will produce an error. This error is generally referred to as aÂ **naming collision**Â (orÂ **naming conflict**).

```cpp
#include <iostream>
// Main File

void myFcn(int x)
{
    std::cout << 2 * x;
}

int main()
{
    return 0;
}
```

```cpp
#include <iostream>
// Second File

void myFcn(int x)
{
    std::cout << x;
}
```
> In this example, When the compiler compiles this program, it will compileÂ _a.cpp_Â andÂ _main.cpp_Â independently, and each file will compile with no problems.
> However, when the linker executes, it will link all the definitions inÂ _a.cpp_Â andÂ _main.cpp_Â together, and discover conflicting definitions for functionÂ `myFcn()`. The linker will then abort with an error. Note that this error occurs even thoughÂ `myFcn()`Â is never called!

### Scope Region
>-Identifiers declared inside the global scope are in scope from the point of declaration to the end of the file.
-Although variables can be defined in the global namespace, this should generally be avoided

### Why Use std directive?
>AÂ **using directive**Â allows us to access the names in a namespace without using a namespace prefix. So in the above example, when the compiler goes to determine what identifierÂ `cout`Â is, it will match withÂ `std::cout`, which, because of the using-directive, is accessible as justÂ `cout`.

```cpp
using namespace std; // no need for using namespace prefix like std::cout
```

### Preprocessor
>Proprocessor is a program.
>It makes changes but not modify the original code but the changes are temporary like striping comments etc.
>When the preprocessor has finished processing a code file, the result is called aÂ **translation unit**. This translation unit is what is then compiled by the compiler.

>The entire process of preprocessing, compiling, and linking is calledÂ **translation**.

### Preprocessor directives
>When the preprocessor runs, it scans through the code file (from top to bottom), looking for preprocessor directives.Â **Preprocessor directives**Â (often just calledÂ _directives_) are instructions that start with aÂ _#_Â symbol and end with a newline (NOT a semicolon). These directives tell the preprocessor to perform certain text manipulation tasks. Note that the preprocessor does not understand C++ syntax -- instead, the directives have their own syntax (which in some cases resembles C++ syntax, and in other cases, not so much).

>**Using Directives** are not preprocessor directives (and thus are not processed by the preprocessor). So while the termÂ `directive`Â _usually_Â means aÂ `preprocessor directive`, this is not always the case.

> When we #include a file then preprocessor replaces the #include file with contents of that file lets say iostream.

>***translation unit***: When the preprocessor has finished processing a code file, the result is called aÂ **translation unit**. This translation unit is what is then compiled by the compiler.
>Each translation unit typically consists of a single code (.cpp) file and all header files it #includes (applied recursively, since header files can #include other header files).

### Conditional Compilation
>TheÂ _conditional compilation_Â preprocessor directives allow you to specify under what conditions something will or wonâ€™t compile.

>TheÂ _#ifdef_Â preprocessor directive allows the preprocessor to check whether an identifier has been previously defined via #define. If so, the code between theÂ _#ifdef_Â and matchingÂ _#endif_Â is compiled. If not, the code is ignored.

```cpp
#include <iostream>

#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout << "Joe\n"; // will be compiled since PRINT_JOE is defined
#endif

#ifdef PRINT_BOB
    std::cout << "Bob\n"; // will be excluded since PRINT_BOB is not defined
#endif

    return 0;
}
```

>In place ofÂ `#ifdef PRINT_BOB`Â andÂ `#ifndef PRINT_BOB`, youâ€™ll also seeÂ `#if defined(PRINT_BOB)`Â andÂ `#if !defined(PRINT_BOB)`. These do the same, but use a slightly more C++-style syntax.

### if 0 conditional compilation
>One more common use of conditional compilation involves usingÂ _#if 0_Â to exclude a block of code from being compiled (as if it were inside a comment block):

```cpp
#include <iostream>

int main()
{
    std::cout << "Joe\n";

#if 0 // Don't compile anything starting here
    std::cout << "Bob\n";
    std::cout << "Steve\n";
#endif // until this point

    return 0;
}
```
> If we change 0 to 1 in if then the code of block will compile

### Macro substitution within other preprocessor commands
```cpp
#define PRINT_JOE

int main()
{
#ifdef PRINT_JOE
    std::cout << "Joe\n"; // will be compiled since PRINT_JOE is defined
#endif

    return 0;
}
```

>Since we definedÂ _PRINT_JOE_Â to be nothing, how come the preprocessor didnâ€™t replaceÂ _PRINT_JOE_Â inÂ _#ifdef PRINT_JOE_Â with nothing and exclude the output statement from compilation?
In most cases, macro substitution does not occur when a macro identifier is used within another preprocessor command.

```cpp
#define FOO 9 // Here's a macro substitution

#ifdef FOO // This FOO does not get replaced with 9 because itâ€™s part of another preprocessor directive
    std::cout << FOO << '\n'; // This FOO gets replaced with 9 because it's part of the normal code
#endif
```

### Header File
> When we use multiple files in our program then we have to do forward declaration for each file and it arises the issue of scalability of files for example what if we have 100+ files so we have to do forward declaration 100 times which is not good so we use the concept of header file, header file contains all the declaration and we just have to include it into our file and we are good.

>Header files allow us to put declarations in one place and then import them wherever we need them. This can save a lot of typing in multi-file programs.

For Example:
```cpp
#include <iostream>

int main()
{
    std::cout << "Hello, world!";
    return 0;
}
```
>_std::cout_Â has been forward declared in the â€œiostreamâ€ header file. When weÂ `#include <iostream>`, weâ€™re requesting that the preprocessor copy all of the content (including forward declarations for std::cout) from the file named â€œiostreamâ€ into the file doing the #include.

>Header files are not added to compile command, they are implicitly included by #include statements and compiled as part of your source files.

>If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).

```cpp
// Second.h

// We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)

// This is the content of the .h file, which is where the declarations go
int add(int x, int y); // function prototype for add.h -- don't forget the semicolon!
```

```cpp
// main.cpp

#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.
#include <iostream>

int main()
{
    std::cout << "The sum of 3 and 4 is " << add(3, 4) << '\n';
    return 0;
}
```

```cpp
// second.cpp

#include "add.h" // Insert contents of add.h at this point.  Note use of double quotes here.

int add(int x, int y)
{
    return x + y;
}
```

>When the preprocessor processes theÂ `#include "add.h"`Â line, it copies the contents of add.h into the current file at that point. Because ourÂ _add.h_Â contains a forward declaration for functionÂ _add()_, that forward declaration will be copied intoÂ _main.cpp_. The end result is a program that is functionally the same as the one where we manually added the forward declaration at the top ofÂ _main.cpp_.

![[Pasted image 20250506200737.png]]

### How including definitions in a header file results in a violation of the one-definition rule
> For now, you should avoid putting function or variable definitions in header files. Doing so will generally result in a violation of the one-definition rule (ODR) in cases where the header file is included into more than one source file.

[Example](https://www.learncpp.com/cpp-tutorial/header-files/#:~:text=How%20including%20definitions,each%20of%20these.)

### For VS Code users

In yourÂ _tasks.json_Â configuration file, add a new line in theÂ _â€œArgsâ€_Â section:  
`"-I./source/includes",`

There is no space after theÂ `-I`. For a full path (rather than a relative path), remove theÂ `.`Â afterÂ `-I`.

### Source files should include their paired headerÂ [](https://www.learncpp.com/cpp-tutorial/header-files/#corresponding_include)
>In C++, it is a best practice for code files to #include their paired header file (if one exists). This allows the compiler to catch certain kinds of errors at compile time instead of link time. For example:

[Example](https://www.learncpp.com/cpp-tutorial/header-files/#:~:text=time.%20For%20example%3A-,add.h%3A,Source%20files%20should%20%23include%20their%20paired%20header%20file%20(if%20one%20exists).,-Do%20not%20%23include)

### Do not #include .cpp files
Although the preprocessor will happily do so, you should generally notÂ `#include`Â .cpp files. These should be added to your project and compiled.

There are number of reasons for this:

- Doing so can cause naming collisions between source files.
- In a large project it can be hard to avoid one definition rules (ODR) issues.
- Any change to such a .cpp file will cause both the .cpp file and any other .cpp file that includes it to recompile, which can take a long time. Headers tend to change less often than source files.
- It is non-conventional to do so.

Best practice

>Avoid #including .cpp files.

### Angled brackets vs double quotesÂ [](https://www.learncpp.com/cpp-tutorial/header-files/#includemethod)

>Use double quotes to include header files that youâ€™ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries youâ€™ve installed elsewhere on your system. (Its A Rule).

### Why doesnâ€™t iostream have a .h extension?

[About This!](https://www.learncpp.com/cpp-tutorial/header-files/#:~:text=Another%20commonly%20asked,a%20.h%20extension.)

>Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.

### Including header files from other directories
[Click Here](https://www.learncpp.com/cpp-tutorial/header-files/#:~:text=Including%20header%20files,every%20code%20file.)

>Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.

### The order of inclusion for header files

- SupposeÂ `headerA.h`Â needs something fromÂ `headerB.h`Â but forgets to include it. Now, the correctness of the code depends on the order of inclusion in the source file:
    
    - If you includeÂ `headerB.h`Â beforeÂ `headerA.h`, the code might compile becauseÂ `headerB.h`'s declarations are visible toÂ `headerA.h`Â when it's processed.
        
    - If you includeÂ `headerA.h`Â first, the compiler will error out becauseÂ `headerA.h`Â uses undeclared types/functions fromÂ `headerB.h`.
        
- The second case (error) is actually better because it reveals the missing include inÂ `headerA.h`, forcing you to fix it.

To catch such missing includes early, follow this order in your source files (e.g.,Â `.cpp`Â files):

1. **The paired header file**:
    
    - If you're inÂ `add.cpp`, includeÂ `add.h`Â first. This ensuresÂ `add.h`Â is self-sufficient (if it isn't, you'll get an error immediately).
        
    - Example:Â `#include "add.h"`.
        
2. **Other headers from the same project**:
    
    - Include other local project headers next. Example:Â `#include "mymath.h"`.
        
3. **3rd-party library headers**:
    
    - Include headers from external libraries (e.g., Boost, Qt). Example:Â `#include <boost/tuple/tuple.hpp>`.
        
4. **Standard library headers**:
    
    - Include standard library headers last. Example:Â `#include <iostream>`.
        

>Why This Order?

- IfÂ `add.h`Â forgets to include a standard library header (e.g.,Â `<string>`), includingÂ `add.h`Â first will likely cause a compile error when the missing dependency is used. This reveals the problem early.
    
- If you included standard library headers first,Â `add.h`Â might accidentally "work" because the needed declarations were pulled in indirectly, hiding the issue.

### The duplicate definition problem
>we noted that a variable or function identifier can only have one definition (the one definition rule). Thus, a program that defines a variable identifier more than once will cause a compile error.

Consider the following academic example:

square.h:
```cpp
int getSquareSides()
{
    return 4;
}
```
wave.h
```cpp
#include "square.h"
```
main.cpp
```cpp
#include "square.h"
#include "wave.h"

int main()
{
    return 0;
}
```
>This seemingly innocent looking program wonâ€™t compile! Hereâ€™s whatâ€™s happening. First,Â _main.cpp_Â #includesÂ _square.h_, which copies the definition for functionÂ _getSquareSides_Â intoÂ _main.cpp_. ThenÂ _main.cpp_Â #includesÂ _wave.h_, which #includesÂ _square.h_Â itself. This copies contents ofÂ _square.h_Â (including the definition for functionÂ _getSquareSides_) intoÂ _wave.h_, which then gets copied intoÂ _main.cpp_.

How to solve this problem?

### Header Guards
>we can avoid the above problem via a mechanism called aÂ **header guard**Â (also called anÂ **include guard**). Header guards are conditional compilation directives that take the following form:

```cpp
#ifndef SOME_UNIQUE_NAME_HERE
#define SOME_UNIQUE_NAME_HERE

// your declarations (and certain types of definitions) here

#endif
```
>When this header is #included, the preprocessor will check whetherÂ _SOME_UNIQUE_NAME_HERE_Â has been previously defined in this translation unit. If this is the first time weâ€™re including the header,Â _SOME_UNIQUE_NAME_HERE_Â will not have been defined. Consequently, it #definesÂ _SOME_UNIQUE_NAME_HERE_Â and includes the contents of the file. If the header is included again into the same file,Â _SOME_UNIQUE_NAME_HERE_Â will already have been defined from the first time the contents of the header were included, and the contents of the header will be ignored (thanks to the #ifndef).

```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

#endif
```
### ğŸ“Œ Important Notes

- `SQUARE_H` can be **any name** â€” but by **convention**, we use:
    
    - The **filename**, in **all caps**, with `_` instead of `.`.
        
    - Example:
        
        - For `square.h` â†’ use `SQUARE_H`
            
        - For `math_utils.h` â†’ use `MATH_UTILS_H`

### Header Guard For Large Project
[Read](https://www.learncpp.com/cpp-tutorial/header-guards/#:~:text=For%20advanced%20readers,or%20FILE_CREATION%2DDATE_H.)

### Updating Our Previous Code with Header Guard

square.h
```cpp
#ifndef SQUARE_H
#define SQUARE_H

int getSquareSides()
{
    return 4;
}

#endif
```
wave.h
```cpp
#ifndef WAVE_H
#define WAVE_H

#include "square.h"

#endif
```
main.cpp
```cpp
#include "square.h"
#include "wave.h"

int main()
{
    return 0;
}
```

After the preprocessor resolves all of the #include directives, this program looks like this:

```cpp
// Square.h included from main.cpp
#ifndef SQUARE_H // square.h included from main.cpp
#define SQUARE_H // SQUARE_H gets defined here

// and all this content gets included
int getSquareSides()
{
    return 4;
}

#endif // SQUARE_H

#ifndef WAVE_H // wave.h included from main.cpp
#define WAVE_H
#ifndef SQUARE_H // square.h included from wave.h, SQUARE_H is already defined from above
#define SQUARE_H // so none of this content gets included

int getSquareSides()
{
    return 4;
}

#endif // SQUARE_H
#endif // WAVE_H

int main()
{
    return 0;
}
```

### Header guards do not prevent a header from being included once into different code files

[Read](https://www.learncpp.com/cpp-tutorial/header-guards/#:~:text=Note%20that%20the%20goal%20of,to%20the%20definition%20of%20getSquareSides)

### Alternative: pragma once
>`#pragma once`Â serves the same purpose as header guards: to avoid a header file from being included multiple times. With traditional header guards, the developer is responsible for guarding the header (by using preprocessor directivesÂ `#ifndef`,Â `#define`, andÂ `#endif`). WithÂ `#pragma once`, weâ€™re requesting that the compiler guard the header. How exactly it does this is an implementation-specific detail.

```cpp
#pragma once

// your code here
```

### How to Design your programs

[Read](https://www.learncpp.com/cpp-tutorial/how-to-design-your-first-programs/#:~:text=Design%20step%201,FAIL%20P.%2071)

>Remember: Donâ€™t implement your entire program in one go. Work on it in steps, testing each step along the way before proceeding.

### Chapter 2: Summary

[Summary](https://www.learncpp.com/cpp-tutorial/chapter-2-summary-and-quiz/)





